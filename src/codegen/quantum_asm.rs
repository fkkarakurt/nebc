//! # Quantum Assembly Generator (Main Compiler Output)
//!
//! This module defines the [`QuantumAssemblyGenerator`], the primary component responsible
//! for orchestrating the entire code generation process. It combines the data, BSS,
//! and text sections, statement translations, and runtime utilities into a single,
//! complete x86-64 assembly file.
//!
//! The generated assembly targets standard Linux environments (using syscalls like `exit`=60).

use super::common::CodeGenCommon;
use super::statement_generator::StatementGenerator;
use crate::ast::nodes::Program;
use crate::compiler::error::CompileError;

/// The main entry point for generating the final executable assembly code.
pub struct QuantumAssemblyGenerator {
    /// The shared context managing variables, strings, and labels across all generation phases.
    common: CodeGenCommon,
}

impl QuantumAssemblyGenerator {
    /// Creates a new instance of the assembly generator with a fresh code generation context.
    pub fn new() -> Self {
        Self {
            common: CodeGenCommon::new(),
        }
    }

    /// Generates the complete x86-64 assembly code for the given Nebulang program AST.
    ///
    /// The process involves:
    /// 1. Generating code for all program statements.
    /// 2. Constructing the static data (`.data`) and uninitialized data (`.bss`) sections.
    /// 3. Assembling the `.text` section, including the program entry point (`_start`)
    ///    and necessary runtime functions.
    ///
    /// # Arguments
    ///
    /// * `program` - The root [`Program`] node of the Abstract Syntax Tree.
    ///
    /// # Returns
    ///
    /// A `Result` containing the final assembly code as a single `String`.
    pub fn generate(&mut self, program: &Program) -> Result<String, CompileError> {
        let mut asm = String::new();

        // --- Header and Metadata ---
        asm.push_str("; ðŸŒŒ NEBULA QUANTUM BINARY v4.0\n");
        asm.push_str("; Generated by NEBC Quantum Compiler\n\n");

        // --- 1. Program Statement Generation (Intermediate Code) ---
        let mut temp_asm = String::new();
        for statement in &program.statements {
            let stmt_asm = StatementGenerator::generate_statement(&mut self.common, statement)?;
            temp_asm.push_str(&stmt_asm);
        }

        // --- 2. Data and BSS Sections ---
        // These sections rely on collected data from the statement generation phase.
        asm.push_str(&self.common.generate_data_section());
        asm.push_str(&self.common.generate_bss_section(program));

        // --- 3. Text Section and Program Entry Point ---
        asm.push_str("section .text\n");
        asm.push_str("global _start\n");
        asm.push_str("_start:\n");

        // Standard function prologue: stack alignment and setup.
        asm.push_str("    mov rbp, rsp\n");
        asm.push_str("    and rsp, 0xFFFFFFFFFFFFFFF0 ; Align stack to 16 bytes\n");

        // Runtime/Protection Initialization
        asm.push_str("    call _nebula_quantum_init\n");

        // --- Execute Program Body ---
        asm.push_str(&temp_asm);

        // --- Program Exit ---
        asm.push_str("    mov rax, 60\n"); // sys_exit (Linux/x86_64)
        asm.push_str("    xor rdi, rdi\n"); // Exit code 0 (success)
        asm.push_str("    syscall\n");

        // --- 4. Runtime Helpers and Security Modules ---
        asm.push_str(&self.common.generate_print_functions());
        asm.push_str(&self.common.generate_quantum_protection());

        Ok(asm)
    }
}
